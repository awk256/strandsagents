
ここでは、Strands SDKの `Swarm` クラスをフル活用した、最も洗練されたマルチエージェント・メッシュ構成（真のSwarm）についてまとめます。

# 概要：Strands Native Swarm（自律分散メッシュ）

この構成は、特定の「指揮者」を介さず、複数の専門エージェントが**共有の実行空間（Swarm Context）** の中で自由に対話・権限委譲を行うモデルです。

- **自律ルーティング**: 各エージェントがプロンプトと現在の状況に基づき、「次は誰にバトンを渡すべきか」をSDKレベルで自動判断します。
    
- **履歴の自動整合性**: 以前発生したBedrockの `ValidationException`（履歴の不整合）を、SDKが内部でメッセージを適切にスタック・整理することで回避します。
    
- **自律終了**: タスクが完了したとエージェントが合意した時点で、システム全体が終了し、最終成果物を返します。
    


```mermaid
graph LR
    User([ユーザー]) -- "依頼" --> SW{Strands Swarm<br/>実行コンテキスト}
    
    subgraph Mesh_Network [自律メッシュ]
        direction TB
        A["Architect<br/>(設計)"] <--> R["Researcher<br/>(調査)"]
        R <--> C["Coder<br/>(実装)"]
        C <--> Rev["Reviewer<br/>(検品)"]
        Rev <--> A
        Rev <--> C
    end
    
    SW <--> Mesh_Network
    Mesh_Network -- "完了合意" --> Result(["最終成果物 (AgentResult)"])

    style SW fill:#f96,stroke:#333
```


- **ハブなしの全方位結合**: 矢印が双方向（`<-->`）かつ網目状に広がっており、どのエージェントからでも他の誰にでも権限を移譲できます。
    
- **Swarm 実行コンテキスト**: `Swarm` クラスがエージェント間の「共通言語」と「対話履歴」を管理するインフラとして機能します。
    
- **動的リレー**: `Architect -> Coder -> Reviewer -> Coder (修正要求) -> Reviewer -> 完了` のように、タスクの難易度に応じて経路がその場で生成されます。
    
# 実装のポイント

- **`strands.multiagent.Swarm` の利用**: 自分で `for` ループやエージェントの呼び出しを書く必要はありません。
    
- **ループ抑止設定**: `repetitive_handoff_...` パラメータにより、AI同士が同じやり取りを繰り返してコストが膨らむのを防ぎます。
    
- **モデルの選択**: 推論能力の高いモデル（Claude 3.5 Sonnet等）を使用することで、ハンドオフ（誰に渡すべきか）の判断精度が劇的に向上します。
    
# サンプルコード

[strands_native_swarm.py]
```
import logging
import sys
from strands import Agent
from strands.multiagent import Swarm
from strands.models.bedrock import BedrockModel

# 1. ログの設定（Swarmの内部挙動を可視化するために重要）
logging.basicConfig(
    level=logging.INFO,
    format="%(levelname)s | %(name)s | %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger("strands.multiagent")
logger.setLevel(logging.DEBUG)

# 2. モデルの初期化
model = BedrockModel(
    region_name="us-east-1",
    model_id="us.anthropic.claude-sonnet-4-20250514-v1:0"
)

# 3. 専門家エージェントの定義
# Swarm内では、エージェントは互いを認識し、自然に役割を移譲します。
researcher = Agent(
    name="researcher",
    model=model,
    system_prompt="あなたは調査スペシャリストです。最新技術や市場動向を調査します。実装が必要な場合はcoderに、設計が必要な場合はarchitectに相談してください。"
)

coder = Agent(
    name="coder",
    model=model,
    system_prompt="あなたはコーディングの専門家です。実装を担当します。コードが書けたら必ずreviewerにレビューを依頼してください。"
)

reviewer = Agent(
    name="reviewer",
    model=model,
    system_prompt="あなたはコードレビューの専門家です。セキュリティ、効率性、可読性を厳しくチェックします。問題があればcoderに差し戻し、完璧なら完了を宣言してください。"
)

architect = Agent(
    name="architect",
    model=model,
    system_prompt="あなたはシステム設計の専門家です。全体の構成を考えます。詳細な調査が必要ならresearcherへ、実装に移れるならcoderへ依頼してください。"
)

# 4. Swarm（メッシュ）の構築
swarm = Swarm(
    agents=[researcher, coder, reviewer, architect],
    max_handoffs=20,           # 最大20回までのバトンタッチを許可
    max_iterations=30,         # 最大30ステップまでの推論を許可
    execution_timeout=900.0,   # 全体で15分制限
    node_timeout=300.0,        # 1エージェントあたり5分制限
    # たらい回し防止機能
    repetitive_handoff_detection_window=8,
    repetitive_handoff_min_unique_agents=3
)

# 5. 実行
if __name__ == "__main__":
    task = "TODOアプリのための、セキュアなREST APIの設計と実装案を作成してください。"
    print(f"🚀 タスク開始: {task}\n")
    
    result = swarm(task)
    
    print("\n" + "="*50)
    print(f"🏁 最終ステータス: {result.status}")
    print(f"回ったノード（履歴）: {[node.node_id for node in result.node_history]}")
    print("="*50)
    print(f"\n📄 最終成果物:\n{result.content}")
```

このコードを実行すると、`DEBUG` ログにより、エージェント同士が「私はここまでやった、次は君の番だ」と相談しながらタスクを進める様子が見て取れます。これこそが、Strands SDKが提供する究極のSwarm実装です。

# 実行

以下、実行結果です。
---

```
python strands_native_swarm.py
```

[70-20-131.実行結果](70-20-131.実行結果.md)

