
**Text-to-SQL**とは、人間が普段使っている言葉（自然言語）を、コンピューターがデータベースを操作するための言語である**SQL（Structured Query Language）に自動変換する技術**のことです。

簡単に言うと、**「専門知識がなくても、AIに話しかけるだけでデータベースからデータを取り出せるようにする翻訳機」** のようなものです。

# 概要

本プログラムは、Strands SDKを用いた**マルチエージェント・オーケストレーション**によって、自然言語から高精度なMySQLクエリを生成するシステムです。

単一のLLMでは見落としがちな「複雑なスキーマへの適合」「ビジネスルールの遵守」「構文の正確性」を、役割の異なる3つのエージェント（親：マネージャー、子：生成担当、子：検証担当）が連携することで解決します。特に、大規模な「プロンプトマニフェスト」を基盤に、MySQL 8.0特有の制約や日付処理、予約語回避などを厳格に守る設計となっています。


```mermaid
graph TD
    User([ユーザー]) --> Manager[親エージェント: マネージャー]
    
    subgraph "内部プロセス (Multi-Agent)"
        Manager -->|1.SQL生成依頼| Gen[ツール化エージェント①: 生成]
        Gen -.->|files/| Profile[(user_profile.json)]
        Gen -.->|files/| Schema[(bookshop_schema.json)]
        Gen -->|JSON: SQL+解説| Manager
        
        Manager -->|2.構文チェック依頼| Val[ツール化エージェント②: 検証]
        Val -->|修正/確認済みSQL| Manager
    end
    
    Manager -->|3.最終回答| Output[標準出力: ヒューマンフレンドリーな解説]
```
### エージェント（マネージャー）:

- 全体のワークフローを管理します。
- ユーザーの質問を適切に解釈し、専門エージェントへタスクを振り分けます。
- 最終的に「技術的なSQL」と「ビジネス向けの解説」を統合し、人間に分かりやすい形式で出力します。
        
### ツール化エージェント①（生成担当）:
    
- **動的コンテキスト注入** : `user_profile.json` を起点に `bookshop_schema.json` を読み込み、プロンプト内の `<<schema_context>>` をリアルタイムで置換して利用します。
        
- **マニフェストの遵守** : プロンプトマニフェストに記載されたMySQL 8.0の制約（MEDIANの擬似再現、CTEの活用、予約語の回避など）を厳格に守ります。
        
- **構造化出力**: 後続の処理がしやすいよう、必ず `question`, `sql`, `description` の3キーを持つJSON形式で回答します。
        
### ツール化エージェント②（検証担当）:
    
- 生成されたSQLが、MySQL 8.0の文法として100%正しいかを「セカンドオピニオン」としてチェックします。
        
- 生成担当が見落とした構文ミスや、複雑なCASE文のカンマミスなどを修正し、品質を担保します。
        
### 外部ファイル連携（Files）:

- データベースの設計書（スキーマ）やユーザー設定を外部ファイル化することで、コードを書き換えることなく異なるデータベース環境へ適応できる拡張性を備えています。

この構成により、「去年の1月から8月までのクロス集計」といった、日付操作と集計が入り混じる難易度の高い要求に対しても、正確なSQLを生成することが可能になります。


# サンプルコード

[text_to_sql.py]
```
import os
import json
from strands import Agent, tool
from strands.models import BedrockModel

# --- モデル設定 ---
model = BedrockModel(
    region_name="us-east-1", 
    model_id="us.anthropic.claude-sonnet-4-20250514-v1:0"
)

# --- 1. ファイル読み込みとコンテキスト生成 ---
def build_schema_context():
    """
    files/bookshop_schema.json を直接読み込み
    """
    try:
        # スクリプトの場所を基準に絶対パスを構築して確実に読み込む
        base_dir = os.path.dirname(os.path.abspath(__file__))
        schema_file_path = os.path.join(base_dir, 'files', 'bookshop_schema.json')
        if not os.path.exists(schema_file_path):
            return f"Error: File not found at {schema_file_path}"

        with open(schema_file_path, 'r', encoding='utf-8') as f:
            schema_content = json.load(f)

        context = json.dumps(schema_content, ensure_ascii=False)
        print(f"[*] スキーマ読み込み成功: {len(context)} 文字")
        return context

    except Exception as e:
        return f"Error loading schema: {str(e)}"

# --- 2. ツール化エージェント①: SQL作成 ---
schema_context = build_schema_context()

GENERATE_SYSTEM_PROMPT = f"""
system_prompt:
  role: "あなたは MySQL v8.0 の SQL 構文に精通したエンジニアであり、同時にビジネス分析の専門家です。あなたの役割は、ユーザーの自然言語の質問の背後にあるビジネス意図を理解し、`user_prompt.schema_context.tables` を参照して、正確かつ効率的な SQL クエリを提案することです。"
  instructions:
    - "SQL 本文とその説明を省略せずに常に完全な形で返してください。"
    - "回答は中断や欠落のない、完全で途切れない内容として返してください。"
    - "出力は日本語のみで回答し、英語やその他の言語を含めないでください。"
    - "`user_prompt.schema_context.tables` のスキーマ定義に存在しない仮想（想像上）のテーブルや列を作成しないでください。"
    - "生成した SQL の構文を必ず再確認してください。特に `user_prompt.rules.reserved_words_that_should_not_be_used` にある予約語を別名として使用している場合は、代替の名称に変更してください。"
  output_format:
    structure: "出力は 'question'、'sql'、'description' の3つのキーを持つ JSON オブジェクトとして返してください。"
    valid_sql_only: "クリーンな SQL のみを提出してください。"

user_prompt:
  schema_context: {schema_context} 
  question: "{{user_question}}"
  policies:
    - "ドメイン知識（例：'Category'、'Genre'）に基づいてテーブルや列を推測・作成しないでください。"
    - "架空のテーブル 'BookCategory' を作成しないでください。"
    - "CREATE、ALTER、DROP などの DDL 文を生成しないでください。"
    - "INSERT、UPDATE、DELETE、MERGE などの DML 文を生成しないでください。"
  rules:
    syntax:
      joins:
        - "サブ宣言の代わりに、明示的な結合（INNER JOIN、LEFT JOIN など）を使用してください。"
        - "カンマによる暗黙的な結合は許可されません。"
        - "同じ列が複数のテーブルに存在する場合は、混乱を避けるため必ずテーブル別名で列を修飾してください。"
      cte:
        - "一時データや段階的集計を構築するために、CTE（WITH 句）を使用することが推奨されます。"
      group_by:
        - "SELECT で使用した式は、GROUP BY でも正確に同じ式を繰り返してください。"
        - "GROUP BY に含まれない非集約列を SELECT に含めないでください。"
        - "HAVING 句で列エイリアスは使用せず、元の集計式を使用してください。"
      reserved_words_that_should_not_be_used:
        - "USER", "ORDER", "TO", "TABLE", "JOIN", "GROUP", "BY", "HAVING", "WHERE", "FROM", "SELECT", "INSERT", "UPDATE", "DELETE", "DROP", "CREATE", "ALTER", "VIEW", "INDEX", "TRIGGER", "PROCEDURE", "FUNCTION", "DATABASE", "SCHEMA", "LIKE", "IN", "AND", "OR", "NOT", "NULL", "TRUE", "FALSE", "IS", "AS", "ON", "BETWEEN", "CASE", "WHEN", "THEN", "ELSE", "END", "WITH", "DISTINCT", "ALL", "UNION", "LIMIT", "OFFSET", "ASC", "DEC", "DESC", "DEFAULT", "VALUES", "SET", "INTO", "DATE", "TIME", "TIMESTAMP", "INTERVAL", "KEY", "PRIMARY", "FOREIGN", "REFERENCES", "CONSTRAINT", "UNIQUE", "CHECK", "COLUMN", "ADD", "MODIFY", "CHANGE", "RANK", "ROW_NUMBER", "DENSE_RANK", "NTILE", "LEAD", "LAG", "FIRST_VALUE", "LAST_VALUE", "OVER", "PARTITION", "ROWS", "RANGE", "UNBOUNDED", "PRECEDING", "FOLLOWING", "CURRENT"
    aliasing:
      - "テーブルに別名を付ける際は常に AS を使用し、すべての列参照をそのテーブル別名で修飾してください。"
    date_handling:
      relative_dates:
        - "'this month' → WHERE order_date BETWEEN DATE_FORMAT(NOW(), '%Y-%m-01') AND LAST_DAY(NOW())"
        - "'last month' → WHERE order_date BETWEEN DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 1 MONTH), '%Y-%m-01') AND LAST_DAY(DATE_SUB(NOW(), INTERVAL 1 MONTH))"
        - "'this year' → WHERE YEAR(order_date) = YEAR(NOW())"
        - "'last year' → WHERE YEAR(order_date) = YEAR(DATE_SUB(NOW(), INTERVAL 1 YEAR))"
    string_formatting:
      escape_and_format:
        - "Python のフォーマット文字列で使用する SQL のパーセント記号はエスケープしてください（例：'%%Y-%%m-%%d'）。"
"""

sql_generator_agent = Agent(
    model=model,
    system_prompt=GENERATE_SYSTEM_PROMPT
)

# --- 3. ツール化エージェント②: シンタックスチェック ---
sql_validator_agent = Agent(
    model=model,
    system_prompt="""あなたは MySQL v8.0 の専門家です。
与えられた SQL の構文をチェックしてください。エラーがある場合は修正し、問題がなければそのままの SQL を返してください。
回答は SQL 文単体、または修正の要約を含めてください。"""
)

# --- 4. 親エージェントから呼び出すツールの定義 ---

@tool
def call_sql_generator(question: str):
    """ユーザーの質問を JSON の階層構造に当てはめて SQL 生成を依頼します。"""
    # システムプロンプトの構造を模倣して入力を渡す
    input_text = f"user_prompt:\n  question: {question}"
    return sql_generator_agent(input_text)

@tool
def call_sql_validator(sql: str):
    """生成された SQL の MySQL 8.0 構文チェックを実行します。"""
    return sql_validator_agent(sql)

# --- 5. 親エージェント（マネージャー） ---

manager = Agent(
    model=model,
    system_prompt="""
あなたは SQL 開発チームのマネージャーです。
以下のステップで業務を遂行してください：
1. 質問を受け取ったら、まず 'call_sql_generator' に SQL の作成を依頼してください。
2. 作成された SQL（json の中の 'sql' キーの値）を 'call_sql_validator' に渡し、構文チェックを受けてください。
3. 最後に、最終的な SQL とその説明を、ユーザーが読みやすい「ヒューマンフレンドリー」な形式で標準出力（回答）してください。
""",
    tools=[call_sql_generator, call_sql_validator]
)

# --- 実行 ---
if __name__ == "__main__":
    questions = [
        "去年の注文の都道府県別の金額を1月から8月までクロス集計して",
        "去年の最も売上が高かった月は",
        "去年の顧客別の売上ランキングトップ10は"
    ]

    for i, q in enumerate(questions, 1):
        print(f"\n[{i}] 質問: {q}")
        print("=" * 50)
        result = manager(q)
        print(result)
        print("=" * 50)
```

付属データを配置します。

- [ブックショップDBのスキーマ](../files/bookshop_schema.json)


# 実行

以下、実行結果です。
---

```
python text_to_sql.py
```

[70-90-011.実行結果](70-90-011.実行結果.md)



